> https://github.com/GraphiteEditor/Graphite/tree/master/node-graph

## Document Graph

**"Document Graph"** refers to the graph presented to users in the editor.  It is represented by the [`NodeNetwork`](https://github.com/GraphiteEditor/Graphite/blob/d9cbf975fff71707d4d37ebccd884657de121d36/node-graph/graph-craft/src/document.rs#L507) struct.

```rust
pub struct NodeNetwork {
	/// The list of data outputs that are exported from this network to the parent network.
	/// Each export is a reference to a node within this network, paired with its output index, that is the source of the network's exported data.
	
  // TODO: Eventually remove this alias document upgrade code
	pub exports: Vec<NodeInput>,
	
  // TODO: Instead of storing import types in each NodeInput::Network connection, the types are stored here. This is similar to how types need to be defined for parameters when creating a function in Rust.
	// pub import_types: Vec<Type>,
	
  /// The list of all nodes in this network.
	pub nodes: FxHashMap<NodeId, DocumentNode>,

	/// A network may expose nodes as constants which can by used by other nodes using a `NodeInput::Scope(key)`.
	pub scope_injections: FxHashMap<String, (NodeId, Type)>,

	pub generated: bool,
}
```

A `DocumentNode` has the following properties:

```rust
/// An instance of a [`DocumentNodeDefinition`] that has been instantiated in a [`NodeNetwork`].
/// Currently, when an instance is made, it lives all on its own without any lasting connection to the definition.
/// But we will want to change it in the future so it merely references its definition.
#[derive(Clone, Debug, PartialEq, Hash, DynAny, serde::Serialize, serde::Deserialize)]
pub struct DocumentNode {
	/// The inputs to a node, which are either:
	/// - From other nodes within this graph [`NodeInput::Node`],
	/// - A constant value [`NodeInput::Value`],
	/// - A [`NodeInput::Network`] which specifies that this input is from outside the graph, which is resolved in the graph flattening step in the case of nested networks.
	///
	/// In the root network, it is resolved when evaluating the borrow tree.
	/// Ensure the click target in the encapsulating network is updated when the inputs cause the node shape to change (currently only when exposing/hiding an input)
	/// by using network.update_click_target(node_id).
	pub inputs: Vec<NodeInput>,

	/// Type of the argument which this node can be evaluated with.
	pub call_argument: Type,
	
  // A nested document network or a proto-node identifier.
	pub implementation: DocumentNodeImplementation,
	
  /// Represents the eye icon for hiding/showing the node in the graph UI. When hidden, a node gets replaced with an identity node during the graph flattening step.
	pub visible: bool,
	
  /// When two different proto nodes hash to the same value (e.g. two value nodes each containing `2_u32` or two multiply nodes that have the same node IDs as input), the duplicates are removed.
	/// See [`ProtoNetwork::generate_stable_node_ids`] for details.
	/// However sometimes this is not desirable, for example in the case of a [`graphene_core::memo::MonitorNode`] that needs to be accessed outside of the graph.
	pub skip_deduplication: bool,
	
  /// The path to this node and its inputs and outputs as of when [`NodeNetwork::generate_node_paths`] was called.
	pub original_location: OriginalLocation,
}
```

Each `DocumentNode` has a particular type, defined by the `DocumentNodeDefinition`:

```rust
// example
DocumentNodeDefinition {
	name: "Opacity",
	category: "Image Adjustments",
	implementation: DocumentNodeImplementation::proto("graphene_core::raster::OpacityNode"),
	inputs: vec![
		DocumentInputType::value("Image", TaggedValue::ImageFrame(ImageFrame::empty()), true),
		DocumentInputType::value("Factor", TaggedValue::F32(100.), false),
	],
	outputs: vec![DocumentOutputType::new("Image", FrontendGraphDataType::Raster)],
	properties: node_properties::multiply_opacity,
	..Default::default()
},
```

Document node definitions can be found in `document_node_definitions.rs`:

```rust
/// Acts as a description for a [DocumentNode] before it gets instantiated as one.
#[derive(Clone)]
pub struct DocumentNodeDefinition {
	/// Used by the reference field in [`DocumentNodeMetadata`] to prevent storing a copy of the implementation, if it is unchanged from the definition.
	pub identifier: &'static str,

	/// All data required to construct a [`DocumentNode`] and [`DocumentNodeMetadata`]
	pub node_template: NodeTemplate,

	/// Definition specific data. In order for the editor to access this data, the reference will be used.
	pub category: &'static str,

	/// User-facing description of the node's functionality.
	pub description: Cow<'static, str>,

	/// Node level overrides are stored based on the reference, not the instance. If the node is modified such that it becomes a local version
	/// (for example an input is added), the reference is no longer to the definition, and the overrides are lost.
	/// Most nodes should not use node based properties, since they are less flexible than input level properties.
	pub properties: Option<&'static str>,
}
```

# Haskell Mock

```haskell
compile :: NodeNetwork -> List ProtoNetwork
```