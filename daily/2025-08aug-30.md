# Graphene Compiler (Voice Meeting 30 Aug 2025)

## Presentation by Dennis

Demos
* Mandelbrot
* 

Document Network -- what the user actually sees

* `NodeNetwork` type (`graph-craft/document.rs`)
* `DocumentNode`
  - `NodeInput` -- passed during network construction
    - Node -- hardcoded value that can't change after graph compiled
    - ValueInput --  can change
  - `call_argument: Type` -- passed at evaluation time


"construction arguments"
- wiring up the graph

"call arguments"
- evaluating the graph

ProtoNode -- (~ atomic node, rust function)
* identifier -- path to rust function

DocumentNetwork gets flattened
* document.rs `flatten_with_fns`
* replaces network inputs with proper node inputs
* then convert every DocumentNode into ProtoNode
* topological sort entire nodegraph to determine linear execution / dependency order
* after topological sort, compute stable node IDs
  * `generate_stable_node_ids`
  * stable node ID = hash of inputs (merkle tree)
  * Invariant:  for two nodes with the same Stable Node ID
      - given the same input they will always return the same output
  * stable node ID - also used for type inference
* type inference
  - for every proto node, determine type signature
  - generics and multiple dispatch (multiple implementations per node) are supported
  - `TypingContext` (contains stable node ids and types inferred per node)
  - currently do bottom-up traversal
    - input type determines output type
  - result of type resolution `TypeErasedNode`
  - typechecking at compile time guarantees that dynamically-typed nodes are compatible at runtime
* execution
  - interpet (use vtable to associate each protonode with precompiled rust function)
  - compile (generate rust file as output)
    - `.eval()`

## Questions

* compiled version / CLI not currently operable
  - easy to implement?
  - maybe trivial after async exec refactor?

* type inference / polymorphism
  - `proto.rs` entrypoint
  - sometimes nodes need to know what they will be used for
  - format conversions
    - example: gpu textures
      - gpu accelerated rendering
      - gpu textures as datatypes in node graph
      - costly to compute gpu textures to cpu versions
      - goal: keep something on the gpu as long as possible
      - avoid converting gpu -> cpu if it will later be used on gpu again
    - example: numeric datatype conversions
  - example: valid input types for node
    - if node input is empty -- infer types that can be fed as input
  - currently only do ad-hoc polymorphism

* want traits / interfaces / typeclasses
* e.g. want to specify that node can take `Renderable` as input
* e.g. transform node has requirement that generic $T$
  - these constraints already exist on rust types
  - but there is no equivalent in Graphite's own type system

* `Extract`
  * receives the node it is connected to, as a document node
  * "macro/reflection"

Higher-Order Nodes
* need to support both dynamic execution and compiled
* `use_vello`

## PRs?

* refactor `infer()`?
  - one function to collect inputs
  - one function which only does type inference
  - on frontend when hover over node want to be able to show supported input types
  - fn
    given some set of already populated inputs
    show what valid types are for other inputs
  - Adam maybe implemented already?
    `resolved_types.rs -> valid_input_types`

--------------------

MemoNode

Transform